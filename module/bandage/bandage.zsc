// AHHHHHHH, I NEED A MEDIC BAG
class UaS_SelfBandage : UaS_MedicalTool {
	int progress;
	int timer;
	int timeout;
	int woundIndex;
	BandageActions actionType;

	override void PostBeginPlay() {
		Super.PostBeginPlay();
		weaponstatus[0] = TYPE_BANDAGE;
		timer = 0;
		progress = 0;
		woundIndex = 0;
		actionType = ACTION_NONE;
	}

	void ResetAction() {
		timer = 0;
		progress = 0;
		actionType = ACTION_NONE;
	}

	override void DoEffect() {
		if (!(owner.player.ReadyWeapon is "UaS_SelfBandage")) { return; }

		Super.DoEffect();

		if (timer >= 0) { --timer; }
		if (timeout >= 0) { --timeout; }
		if (timeout <= 0) { ResetAction(); }

		if (owner.player.cmd.buttons & BT_ATTACK) { TryBandage(); }
		else if (owner.player.cmd.buttons & BT_ALTATTACK) { TryRipBandage(); }
		else { CycleWounds(); }
		/*
		if (
			timer <= 0
			&& owner.player.cmd.buttons & BT_FIREMODE
			&& !(owner.player.oldbuttons & BT_FIREMODE)
		) { ++weaponstatus[0]; }
		if (weaponstatus[0] > TYPE_BANDAGE) { weaponstatus[0] = TYPE_IMPROVISED; }
		*/
	}

	// also updates wounds
	void CycleWounds() {
		if (wh.critWounds.Size() == 0) { return; }

		if (owner.player.cmd.buttons & BT_RELOAD && !(owner.player.oldbuttons & BT_RELOAD)) {
			++woundIndex;
			ResetAction();
		}
		else if (owner.player.cmd.buttons & BT_ALTRELOAD && !(owner.player.oldbuttons & BT_ALTRELOAD)) {
			--woundIndex;
			ResetAction();
		}

		if (woundIndex < 0 || (!currentWound && woundIndex >= wh.critWounds.Size())) {
			woundIndex = wh.critWounds.Size() - 1;
		}
		else if (woundIndex >= wh.critWounds.Size()) { woundIndex = 0; }

		currentWound = GetWound(woundIndex);
	}

	void BandageWound(float toPatch, float pressure) {
		if (!currentWound) { return; }

		currentWound.Patch(toPatch);
		currentWound.pressure += pressure;
	}

	void BandageEffect(int min, int max) {
		timer = Random(min, max);
		HDPlayerPawn(owner).A_MuzzleClimb((FRandom(-1.5, 1.8), FRandom(-2.4, 2.4)), (0, 0), (0, 0), (0, 0));
		owner.A_StartSound("bandage/rustle", CHAN_BODY, CHANF_OVERLAP);
	}

	void TryBandage() {
		if (!currentWound) { return; }
		if (patient == owner && owner.pitch < 45) { owner.pitch += 6; return; }

		if ((timer <= 0 && timeout <= 0) || actionType != ACTION_BANDAGE) {
			timeout = 5;
			progress = 0;
			actionType = ACTION_BANDAGE;
			owner.A_StartSound("bandage/rip", CHAN_WEAPON, CHANF_OVERLAP, 0.4);
			BandageEffect(5, 10);
			return;
		}
		else if (timer <= 0 && timeout > 0) { ++progress; }
		else { timeout = 5; return; }

		switch (progress) {
			case 1:
				BandageEffect(30, 40);
				break;

			case 2:
				BandageEffect(30, 35);
				break;

			case 3:
				BandageEffect(15, 20);
				break;

			default:
				BandageEffect(4, 8);
				owner.A_StartSound("weapons/pocket", CHAN_BODY, CHANF_OVERLAP);
				owner.A_ChangeVelocity(FRandom(-0.3, 0.3), FRandom(-0.3, 0.3), FRandom(-1, 2));

				progress = 0;
				BandageWound(FRandom(20, 30), FRandom(0.25, 0.95));
				break;
		}
	}

	void TryRipBandage() {
		if (!currentWound || currentWound.patched <= 0.) { return; }
		if (patient == owner && owner.pitch < 45) { owner.pitch += 6; return; }

		if ((timer <= 0 && timeout <= 0) || actionType != ACTION_RIPBANDAGE) {
			timeout = 5;
			progress = 0;
			actionType = ACTION_RIPBANDAGE;
			BandageEffect(5, 10);
			return;
		}
		else if (timer <= 0 && timeout > 0) { ++progress; }
		else { timeout = 5; return; }

		switch (progress) {
			case 1:
			case 2:
			case 3:
			case 4:
				BandageEffect(4, 10);
				break;

			default:
				BandageEffect(0, 0);
				owner.A_StartSound("bandage/rip", CHAN_BODY, CHANF_OVERLAP);
				owner.A_ChangeVelocity(FRandom(-0.3, 0.3), FRandom(-0.3, 0.3), FRandom(-1, 2));

				progress = 0;
				currentWound.depth += currentWound.patched;
				currentWound.patched = 0;
				currentWound.pressure = 0;
				break;
		}
	}

	enum BandageTypes {
		TYPE_IMPROVISED,
		TYPE_BANDAGE,
	};

	enum BandageActions {
		ACTION_NONE,
		ACTION_BANDAGE,
		ACTION_RIPBANDAGE,
	};
}
