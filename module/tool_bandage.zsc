// AHHHHHHH, I NEED A MEDIC BAG
class UaS_SelfBandage : UaS_MedicalTool {
	int progress;
	int timer;
	int timeout;
	int woundIndex;

	override void PostBeginPlay() {
		Super.PostBeginPlay();
		weaponstatus[0] = TYPE_BANDAGE;
		timer = 0;
		progress = 0;
		woundIndex = 0;
	}

	override void DoEffect() {
		if (!(owner.player.ReadyWeapon is "UaS_SelfBandage")) { return; }

		Super.DoEffect();

		if (timer >= 0) { --timer; }
		if (timeout >= 0) { --timeout; }
		if (timeout <= 0) {
			timer = 0;
			progress = 0;
		}

		if (owner.player.cmd.buttons & BT_ATTACK) { TryBandage(); }
		else { CycleWounds(); }
		/*
		if (
			timer <= 0
			&& owner.player.cmd.buttons & BT_FIREMODE
			&& !(owner.player.oldbuttons & BT_FIREMODE)
		) { ++weaponstatus[0]; }
		if (weaponstatus[0] > TYPE_BANDAGE) { weaponstatus[0] = TYPE_IMPROVISED; }
		*/
	}

	// also updates wounds
	void CycleWounds() {
		if (wh.critWounds.Size() == 0) { return; }

		if (owner.player.cmd.buttons & BT_RELOAD && !(owner.player.oldbuttons & BT_RELOAD)) {
			++woundIndex;
		}
		else if (owner.player.cmd.buttons & BT_ALTRELOAD && !(owner.player.oldbuttons & BT_ALTRELOAD)) {
			--woundIndex;
		}

		if (woundIndex < 0 || (!currentWound && woundIndex >= wh.critWounds.Size())) {
			woundIndex = wh.critWounds.Size() - 1;
		}
		else if (woundIndex >= wh.critWounds.Size()) { woundIndex = 0; }

		currentWound = GetWound(woundIndex);
	}

	void BandageWound(float toPatch, float pressure) {
		if (!currentWound) { return; }

		currentWound.Patch(toPatch);
		currentWound.pressure += pressure;
	}

	void BandageEffect(int min, int max) {
		timer = Random(min, max);
		A_MuzzleClimb(FRandom(-1.5, 1.8), FRandom(-2.4, 2.4));
		A_StartSound("bandage/rustle", CHAN_BODY, CHANF_OVERLAP);
	}

	void TryBandage() {
		if (!currentWound) { return; }

		timeout = 5;
		if (timer <= 0 && timeout <= 0) {
			timeout = 5;
			progress = 0;
			BandageEffect(5, 10);
			A_StartSound("bandage/rip", CHAN_WEAPON, CHANF_OVERLAP, 0.4);
			return;
		}
		else if (timer <= 0 && timeout > 0) { ++progress; }
		else { return; }

		switch (progress) {
			case 1:
				BandageEffect(30, 40);
				break;

			case 2:
				BandageEffect(30, 35);
				break;

			case 3:
				BandageEffect(15, 20);
				break;

			default:
				BandageWound(FRandom(20, 30), FRandom(0.025, 0.1));
				progress = 1;
				A_StartSound("bandage/pocket", CHAN_BODY, CHANF_OVERLAP);
				A_ChangeVelocity(FRandom(-0.3, 0.3), FRandom(-0.3, 0.3), FRandom(-1, 2));
				break;
		}
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl) {
		// Draw Weapon Status
		Super.DrawHUDStuff(sb, hdw, hpl);

		// debug
		Screen.DrawText(
			NewSmallFont,
			OptionMenuSettings.mFontColorValue,
			10, Screen.GetHeight() * 2 / 3,
			"type: "..weaponstatus[0].." | timer: "..timer.." | progress: "..progress.." | timeout: "..timeout
		);

		Vector2 hudScale = (1.00, 1.00);
		float textHeight = sb.pSmallFont.mFont.GetHeight() * hudscale.y;
		float padding = 2 * hudScale.y;
		float padStep = textHeight + padding;
		float baseOffset = (-8 * textHeight) + (-3 * padding);

		// Title
		sb.DrawString(
			sb.pSmallFont,
			"--- Bandaging ---",
			(0, baseOffset),
			sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER,
			Font.CR_GRAY,
			scale: hudScale
		);

		// cool grid
		int gridAlpha = 25;
		sb.Fill(
			Color(gridAlpha, sb.sbcolour.r, sb.sbcolour.g, sb.sbcolour.b),
			-62 * hudScale.x, -60 * hudScale.y,
			124 * hudScale.x, 120 * hudScale.y,
			sb.DI_SCREEN_CENTER
		);
		for (int i = 0; i < 60; i++)
		{
			sb.Fill(
				Color(gridAlpha, sb.sbcolour.r, sb.sbcolour.g, sb.sbcolour.b),
				-60 * hudScale.x, (-60 + i * 2) * hudScale.y,
				120 * hudScale.x, 1 * hudScale.y,
				sb.DI_SCREEN_CENTER
			);
		}
		for (int i = 0; i < 11; i++)
		{
			sb.Fill(
				Color(gridAlpha, sb.sbcolour.r, sb.sbcolour.g, sb.sbcolour.b),
				(-50 + 10 * i) * hudScale.x, -60 * hudScale.y,
				1 * hudScale.x, 120 * hudScale.y,
				sb.DI_SCREEN_CENTER
			);
			sb.Fill(
				Color(gridAlpha, sb.sbcolour.r, sb.sbcolour.g, sb.sbcolour.b),
				-60 * hudScale.x, (-50 + 10 * i) * hudScale.y,
				120 * hudScale.x, 1 * hudScale.y,
				sb.DI_SCREEN_CENTER
			);
		}

		// Wounds
		if (!wh) { return; }
		if (wh.critWounds.Size() == 0) {
			sb.DrawString(
				sb.pSmallFont,
				"You have no wounds.",
				(0, 0),
				sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER,
				Font.CR_BLACK,
				scale: hudScale
			);
			return;
		}

		for (int i = 0; i < wh.critWounds.Size(); i++)
		{
			UaS_Wound wound = wh.critWounds[i];
			if (!wound) { continue; }

			int col;
			if (i == woundIndex) { col = (wound.depth <= 0.)? Font.CR_GOLD : Font.CR_RED; }
			else { col = (wound.depth <= 0.)? Font.CR_YELLOW : Font.CR_DARKRED; }

			// location.x is the angle that you got hit from
			// location.y is the height that you got hit at
			sb.DrawString(
				sb.pSmallFont,
				"X",
				(50 * sin(wound.location.x), 50 * wound.location.y),
				sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER,
				col,
				scale: hudScale
			);
		}
	}

	enum BandageTypes {
		TYPE_IMPROVISED,
		TYPE_BANDAGE,
	};
}
